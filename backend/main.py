from executor import Executor
from planner import Planner
from task import Task
import os
from dotenv import load_dotenv


def main():
    """
    Main function to coordinate the pentest workflow:
    1. Loads API key from the environment.
    2. Creates a Planner and Executor.
    3. Executes tasks generated by the Planner using the Executor.
    """
    # Load environment variables
    load_dotenv()
    api_key = os.getenv("HF_API")
    if not api_key:
        print("Error: Please provide an API key for OpenAI in the .env file.")
        return

    # Input target IP address
    target_ip = input("Enter the target IP address to start the pentest: ").strip()
    if not target_ip:
        print("Error: Target IP address is required.")
        return

    # Create Planner and Executor
    planner = Planner(target_ip=target_ip, api_key=api_key)
    executor = Executor(api_key=api_key)

    # Generate attack plan
    planner.create_attack_plan()
    planner.display_task_plan()
    print(f"Total tasks created: {len(planner.tasks)}\n")

    # Process tasks
    while True:
        # Fetch the next task
        has_task = executor.fetch_task_from_planner(planner)
        if not has_task:
            print("All tasks have been processed. Exiting.")
            break

        # Validate the task
        if not isinstance(executor.current_task, Task):
            print("Error: Fetched task is not a valid Task object. Skipping.")
            continue

        # Execute the current task
        current_task = executor.current_task
        print(f"\nExecuting Task {current_task.id}: {current_task.description}")

        # Run the task and update its status
        try:
            status, result = executor.run_task(current_task.description, planner.target_ip)
            planner.update_task(current_task.id, status=status, result=result)

            # Log the task result
            print(f"Task {current_task.id} Status: {status}")
            print(f"Result: {result}\n")
        except Exception as e:
            # Handle unexpected errors during task execution
            print(f"Error while executing Task {current_task.id}: {e}")
            planner.update_task(current_task.id, status="error", result=str(e))

    # Display the final task plan
    print("\nFinal Task Plan:")
    planner.display_task_plan()


if __name__ == "__main__":
    main()
